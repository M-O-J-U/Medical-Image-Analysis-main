{
 "cells": [
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "7fd51504-08c5-467f-885a-36529d0994aa",
   "metadata": {},
   "outputs": [
    {
     "ename": "NameError",
     "evalue": "name '__file__' is not defined",
     "output_type": "error",
     "traceback": [
      "\u001b[1;31m---------------------------------------------------------------------------\u001b[0m",
      "\u001b[1;31mNameError\u001b[0m                                 Traceback (most recent call last)",
      "Cell \u001b[1;32mIn[5], line 12\u001b[0m\n\u001b[0;32m      9\u001b[0m \u001b[38;5;28;01mfrom\u001b[39;00m \u001b[38;5;21;01mpathlib\u001b[39;00m \u001b[38;5;28;01mimport\u001b[39;00m Path\n\u001b[0;32m     11\u001b[0m \u001b[38;5;66;03m# Check the model path and existence\u001b[39;00m\n\u001b[1;32m---> 12\u001b[0m model_onnx_path \u001b[38;5;241m=\u001b[39m os\u001b[38;5;241m.\u001b[39mpath\u001b[38;5;241m.\u001b[39mjoin(os\u001b[38;5;241m.\u001b[39mpath\u001b[38;5;241m.\u001b[39mdirname(os\u001b[38;5;241m.\u001b[39mpath\u001b[38;5;241m.\u001b[39mabspath(\u001b[38;5;18m__file__\u001b[39m)), \u001b[38;5;124m\"\u001b[39m\u001b[38;5;124myolov7-p6-bonefracture.onnx\u001b[39m\u001b[38;5;124m\"\u001b[39m)\n\u001b[0;32m     13\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mModel path: \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mmodel_onnx_path\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m\"\u001b[39m)\n\u001b[0;32m     14\u001b[0m \u001b[38;5;28mprint\u001b[39m(\u001b[38;5;124mf\u001b[39m\u001b[38;5;124m\"\u001b[39m\u001b[38;5;124mModel exists: \u001b[39m\u001b[38;5;132;01m{\u001b[39;00mos\u001b[38;5;241m.\u001b[39mpath\u001b[38;5;241m.\u001b[39mexists(model_onnx_path)\u001b[38;5;132;01m}\u001b[39;00m\u001b[38;5;124m\"\u001b[39m)\n",
      "\u001b[1;31mNameError\u001b[0m: name '__file__' is not defined"
     ]
    }
   ],
   "source": [
    "import os\n",
    "import cv2\n",
    "import numpy as np\n",
    "import streamlit as st\n",
    "import onnxruntime as ort\n",
    "import tensorflow as tf\n",
    "from matplotlib.colors import TABLEAU_COLORS\n",
    "from pathlib import Path\n",
    "\n",
    "ALLOWED_EXTENSIONS = {\"txt\", \"pdf\", \"png\", \"jpg\", \"jpeg\", \"gif\"}\n",
    "parent_root = Path(__file__).parent.parent.absolute().__str__()\n",
    "h, w = 640, 640\n",
    "model_onnx_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"yolov7-p6-bonefracture.onnx\")\n",
    "device = \"cpu\"\n",
    "\n",
    "brain_tumor_model_path = os.path.join(os.path.dirname(os.path.abspath(__file__)), \"brain_tumor_detector.h5\")\n",
    "brain_tumor_model = tf.keras.models.load_model(brain_tumor_model_path)\n",
    "\n",
    "def color_list():\n",
    "    def hex2rgb(h):\n",
    "        return tuple(int(h[1 + i:1 + i + 2], 16) for i in (0, 2, 4))\n",
    "\n",
    "    return [hex2rgb(h) for h in TABLEAU_COLORS.values()]\n",
    "\n",
    "colors = color_list()\n",
    "\n",
    "def xyxy2xywhn(bbox, H, W):\n",
    "    x1, y1, x2, y2 = bbox\n",
    "    return [0.5 * (x1 + x2) / W, 0.5 * (y1 + y2) / H, (x2 - x1) / W, (y2 - y1) / H]\n",
    "\n",
    "def xywhn2xyxy(bbox, H, W):\n",
    "    x, y, w, h = bbox\n",
    "    return [(x - w / 2) * W, (y - h / 2) * H, (x + w / 2) * W, (y + h / 2) * H]\n",
    "\n",
    "def load_img(uploaded_file):\n",
    "    file_bytes = np.asarray(bytearray(uploaded_file.read()), dtype=np.uint8)\n",
    "    opencv_image = cv2.imdecode(file_bytes, 1)\n",
    "    return opencv_image[..., ::-1]\n",
    "\n",
    "class DisplayTumor:\n",
    "    curImg = 0\n",
    "    Img = 0\n",
    "\n",
    "    def readImage(self, img):\n",
    "        self.Img = np.array(img)\n",
    "        self.curImg = np.array(img)\n",
    "        gray = cv.cvtColor(np.array(img), cv.COLOR_BGR2GRAY)\n",
    "        self.ret, self.thresh = cv.threshold(gray, 0, 255, cv.THRESH_BINARY_INV + cv.THRESH_OTSU)\n",
    "\n",
    "    def getImage(self):\n",
    "        return self.curImg\n",
    "\n",
    "    def removeNoise(self):\n",
    "        self.kernel = np.ones((3, 3), np.uint8)\n",
    "        opening = cv.morphologyEx(self.thresh, cv.MORPH_OPEN, self.kernel, iterations=2)\n",
    "        self.curImg = opening\n",
    "\n",
    "    def displayTumor(self):\n",
    "        sure_bg = cv.dilate(self.curImg, self.kernel, iterations=3)\n",
    "        dist_transform = cv.distanceTransform(self.curImg, cv.DIST_L2, 5)\n",
    "        ret, sure_fg = cv.threshold(dist_transform, 0.7 * dist_transform.max(), 255, 0)\n",
    "        sure_fg = np.uint8(sure_fg)\n",
    "        unknown = cv.subtract(sure_bg, sure_fg)\n",
    "        ret, markers = cv.connectedComponents(sure_fg)\n",
    "        markers = markers + 1\n",
    "        markers[unknown == 255] = 0\n",
    "        markers = cv.watershed(self.Img, markers)\n",
    "        self.Img[markers == -1] = [255, 0, 0]\n",
    "        tumorImage = cv.cvtColor(self.Img, cv.COLOR_HSV2BGR)\n",
    "        self.curImg = tumorImage\n",
    "\n",
    "def preprocess_brain_tumor_img(img):\n",
    "    img = cv2.resize(img, (240, 240))\n",
    "    img = img / 255.0\n",
    "    return np.expand_dims(img, axis=0)\n",
    "\n",
    "def detect_and_display_brain_tumor(img):\n",
    "    preprocessed_img = preprocess_brain_tumor_img(img)\n",
    "    prediction = brain_tumor_model.predict(preprocessed_img)\n",
    "    display_tumor = DisplayTumor()\n",
    "    display_tumor.readImage(img)\n",
    "    display_tumor.removeNoise()\n",
    "    display_tumor.displayTumor()\n",
    "    tumor_img = display_tumor.getImage()\n",
    "    tumor_detected = \"Brain Tumor Detected\" if np.argmax(prediction) == 1 else \"Tumor/Fracture Region\"\n",
    "    return tumor_img, tumor_detected\n",
    "\n",
    "def preproc(img):\n",
    "    img = cv2.resize(img, (w, h), interpolation=cv2.INTER_LINEAR)\n",
    "    img = img.astype(np.float32).transpose(2, 0, 1) / 255\n",
    "    return np.expand_dims(img, axis=0)\n",
    "\n",
    "def model_inference(model_path, image_np, device=\"cpu\"):\n",
    "    providers = [\"CPUExecutionProvider\"]\n",
    "    session = ort.InferenceSession(model_path, providers=providers)\n",
    "    input_name = session.get_inputs()[0].name\n",
    "    output_name = session.get_outputs()[0].name\n",
    "    output = session.run([output_name], {input_name: image_np})\n",
    "    return output[0][:, :6]\n",
    "\n",
    "def post_process(img, output, score_threshold=0.3):\n",
    "    det_bboxes, det_scores, det_labels = output[:, 0:4], output[:, 4], output[:, 5]\n",
    "    id2names = {\n",
    "        0: \"boneanomaly\", 1: \"bonelesion\", 2: \"foreignbody\",\n",
    "        3: \"fracture\", 4: \"metal\", 5: \"periostealreaction\",\n",
    "        6: \"pronatorsign\", 7: \"softtissue\", 8: \"text\"\n",
    "    }\n",
    "\n",
    "    if isinstance(img, str):\n",
    "        img = cv2.imread(img)\n",
    "\n",
    "    img = img.astype(np.uint8)\n",
    "    H, W = img.shape[:2]\n",
    "    label_txt = \"\"\n",
    "\n",
    "    for idx in range(len(det_bboxes)):\n",
    "        if det_scores[idx] > score_threshold:\n",
    "            bbox = det_bboxes[idx]\n",
    "            label = det_labels[idx]\n",
    "            bbox = xyxy2xywhn(bbox, h, w)\n",
    "            label_txt += f\"{int(label)} {det_scores[idx]:.5f} {bbox[0]:.5f} {bbox[1]:.5f} {bbox[2]:.5f} {bbox[3]:.5f}\\n\"\n",
    "            bbox = xywhn2xyxy(bbox, H, W)\n",
    "            bbox_int = [int(x) for x in bbox]\n",
    "            x1, y1, x2, y2 = bbox_int\n",
    "            color_map = colors[int(label)]\n",
    "            txt = f\"{id2names[label]} {det_scores[idx]:.2f}\"\n",
    "            (text_width, text_height), _ = cv2.getTextSize(txt, cv2.FONT_HERSHEY_SIMPLEX, 0.5, 2)\n",
    "            cv2.rectangle(img, (x1, y1), (x2, y2), color_map, 2)\n",
    "            cv2.rectangle(img, (x1 - 2, y1 - text_height - 10), (x1 + text_width + 2, y1), color_map, -1)\n",
    "            cv2.putText(img, txt, (x1, y1 - 5), cv2.FONT_HERSHEY_SIMPLEX, 0.5, (255, 255, 255), 2)\n",
    "\n",
    "    return img, label_txt\n",
    "\n",
    "if __name__ == \"__main__\":\n",
    "    st.title(\"Medical Image Analysis\")\n",
    "\n",
    "    st.markdown(\n",
    "        '<script async src=\"https://pagead2.googlesyndication.com/pagead/js/adsbygoogle.js?client=ca-pub-6840837431951843\" crossorigin=\"anonymous\"></script>',\n",
    "        unsafe_allow_html=True\n",
    "    )\n",
    "\n",
    "    uploaded_file = st.file_uploader(\"Choose an image file\", type=[\"png\", \"jpg\", \"jpeg\", \"gif\"])\n",
    "\n",
    "    if uploaded_file is not None:\n",
    "        conf_thres = st.slider(\"Object confidence threshold\", 0.2, 1., step=0.05)\n",
    "        img = load_img(uploaded_file)\n",
    "        img_pp = preproc(img)\n",
    "        out = model_inference(model_onnx_path, img_pp, device)\n",
    "        out_img, out_txt = post_process(img, out, conf_thres)\n",
    "        st.image(out_img, caption=\"Detection Region\", channels=\"RGB\")\n",
    "        tumor_img, brain_tumor_result = detect_and_display_brain_tumor(img)\n",
    "        st.write(brain_tumor_result)\n",
    "        st.image(tumor_img, caption=\"Detected Abnormality Region\", channels=\"RGB\")\n",
    "\n",
    "        col1, col2 = st.columns(2)\n",
    "        col1.download_button(\n",
    "            label=\"Download Prediction\",\n",
    "            data=cv2.imencode(\".png\", out_img[..., ::-1])[1].tobytes(),\n",
    "            file_name=uploaded_file.name,\n",
    "            mime=\"image/png\"\n",
    "        )\n",
    "        col2.download_button(\n",
    "            label=\"Download Detections\",\n",
    "            data=out_txt,\n",
    "            file_name=uploaded_file.name[:-4] + \".txt\",\n",
    "            mime=\"text/plain\"\n",
    "        )\n",
    "s"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": null,
   "id": "2ada884f-1d71-47c0-9b3a-02018628021d",
   "metadata": {},
   "outputs": [],
   "source": []
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3 (ipykernel)",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.11.7"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
